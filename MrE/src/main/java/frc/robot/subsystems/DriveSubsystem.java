// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.RobotContainer;
import frc.robot.Constants.DriveConstants;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.kauailabs.navx.frc.AHRS;
// import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.math.filter.SlewRateLimiter;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.SPI.Port;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveSubsystem extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax m_driveRightLeader;
    private CANSparkMax m_driveRightFollower;
    private MotorControllerGroup m_driveRight;
    private CANSparkMax m_driveLeftLeader;
    private CANSparkMax m_driveLeftFollower;
    private MotorControllerGroup m_driveLeft;
    private DifferentialDrive differentialDrive;
    private AHRS m_gyro;
    private RelativeEncoder m_encoderRightDrive;
    private RelativeEncoder m_encoderLeftDrive;
    private final DifferentialDriveOdometry m_odometry;
    private boolean curvatureDriveMode = false;
    private boolean rightStickMode = false;
    protected XboxController pilotController;
    private SlewRateLimiter accelerationLimiter = new SlewRateLimiter(DriveConstants.kAcellerationLimit);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public DriveSubsystem() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_driveRightLeader = new CANSparkMax(0, MotorType.kBrushless);

        m_driveRightLeader.restoreFactoryDefaults();
        m_driveRightLeader.setInverted(true);
        m_driveRightLeader.setIdleMode(IdleMode.kBrake);

        m_driveRightFollower = new CANSparkMax(1, MotorType.kBrushless);

        m_driveRightFollower.restoreFactoryDefaults();
        m_driveRightFollower.setInverted(true);
        m_driveRightFollower.setIdleMode(IdleMode.kBrake);
        m_driveRightFollower.follow(m_driveRightLeader);

        m_driveRight = new MotorControllerGroup(m_driveRightLeader, m_driveRightFollower);
        addChild("m_driveRight", m_driveRight);

        m_driveLeftLeader = new CANSparkMax(2, MotorType.kBrushless);

        m_driveLeftLeader.restoreFactoryDefaults();
        m_driveLeftLeader.setInverted(false);
        m_driveLeftLeader.setIdleMode(IdleMode.kBrake);

        m_driveLeftFollower = new CANSparkMax(3, MotorType.kBrushless);

        m_driveLeftFollower.restoreFactoryDefaults();
        m_driveLeftFollower.setInverted(false);
        m_driveLeftFollower.setIdleMode(IdleMode.kBrake);
        m_driveLeftFollower.follow(m_driveLeftLeader);

        m_driveLeft = new MotorControllerGroup(m_driveLeftLeader, m_driveLeftFollower);
        addChild("m_driveLeft", m_driveLeft);

        differentialDrive = new DifferentialDrive(m_driveRight, m_driveRightLeader);
        addChild("DifferentialDrive", differentialDrive);
        differentialDrive.setSafetyEnabled(true);
        differentialDrive.setExpiration(0.1);
        differentialDrive.setMaxOutput(1.0);

        m_gyro = new AHRS(Port.kMXP, (byte) 50);
        addChild("Gyro", m_gyro);

        m_encoderRightDrive = m_driveRightLeader.getEncoder();
        m_encoderRightDrive.setPositionConversionFactor(DriveConstants.kEncoderPositionConversionFactor);
        m_encoderRightDrive.setVelocityConversionFactor(DriveConstants.kEncoderVelocityConversionFactor);
        m_encoderRightDrive.setInverted(true);

        m_encoderLeftDrive = m_driveLeftLeader.getEncoder();
        m_encoderLeftDrive.setPositionConversionFactor(DriveConstants.kEncoderPositionConversionFactor);
        m_encoderLeftDrive.setVelocityConversionFactor(DriveConstants.kEncoderVelocityConversionFactor);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        resetEncoders();
        m_odometry = new DifferentialDriveOdometry(m_gyro.getRotation2d());
    }

    public void resetEncoders() {
        m_encoderLeftDrive.setPosition(0);
        m_encoderRightDrive.setPosition(0);
    }

    public void resetGyro() {
        m_gyro.reset();
    }

    public void zeroHeading() {
        m_gyro.reset();
    }

    public void resetOdometry(Pose2d pose) {
        resetEncoders();
        m_odometry.resetPosition(pose, m_gyro.getRotation2d());
    }

    public void setMaxOutput(double maxOutput) {
        differentialDrive.setMaxOutput(maxOutput);
    }

    public Pose2d getPose() {
        return m_odometry.getPoseMeters();
    }

    public double getAverageEncoderDistance() {
        return (m_encoderLeftDrive.getPosition() + m_encoderRightDrive.getPosition()) / 2.0;
    }

    public double getAverageEncoderVelocity() {
        return (m_encoderLeftDrive.getVelocity() + m_encoderRightDrive.getVelocity()) / 2.0;
    }

    public RelativeEncoder getLeftEncoder() {
        return m_encoderLeftDrive;
    }

    public RelativeEncoder getRightEncoder() {
        return m_encoderRightDrive;
    }

    public Rotation2d getHeading() {
        return Rotation2d.fromDegrees(-m_gyro.getAngle());
    }

    public double getTurnRate() {
        return -m_gyro.getRate();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        SmartDashboard.putBoolean("NaxX Connected", m_gyro.isConnected());
        SmartDashboard.putNumber("Avg Velocity", getAverageEncoderVelocity());
        SmartDashboard.putNumber("Avg Distance", getAverageEncoderDistance());
        SmartDashboard.putBoolean("Curvature Drive", curvatureDriveMode);
        SmartDashboard.putBoolean("Right Stick Steer", rightStickMode);
        m_odometry.update(
                m_gyro.getRotation2d(), m_encoderLeftDrive.getPosition(), m_encoderRightDrive.getPosition());
    }

    public DifferentialDriveWheelSpeeds getWheelSpeeds() {
        return new DifferentialDriveWheelSpeeds(m_encoderLeftDrive.getVelocity(), m_encoderRightDrive.getVelocity());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void arcadeDrive(double fwd, double rot) {
        differentialDrive.arcadeDrive(fwd, rot);
    }

    public void tankDriveVolts(double leftVolts, double rightVolts) {
        m_driveLeft.setVoltage(leftVolts);
        m_driveRight.setVoltage(rightVolts);
        differentialDrive.feed();
    }

    public void pilotDrive() {
        if (pilotController == null) {
            pilotController = RobotContainer.getInstance().getcontrollerPilot();
        }
        if (curvatureDriveMode) {
            if (rightStickMode) {
                differentialDrive.curvatureDrive(
                        -accelerationLimiter.calculate(
                                pilotController.getLeftY()),
                        pilotController.getRightX() * DriveConstants.kSteeringOutputModifier,
                        pilotController.getRawButton(10));
            } else {
                differentialDrive.curvatureDrive(
                        -accelerationLimiter.calculate(
                                pilotController.getLeftY()),
                        pilotController.getLeftX() * DriveConstants.kSteeringOutputModifier,
                        pilotController.getRawButton(10));
            }
        } else {
            if (rightStickMode) {
                differentialDrive.arcadeDrive(
                        -accelerationLimiter.calculate(
                                pilotController.getLeftY()),
                        pilotController.getRightX() * DriveConstants.kSteeringOutputModifier);
            } else {
                differentialDrive.arcadeDrive(
                        -accelerationLimiter.calculate(
                                pilotController.getLeftY()),
                        pilotController.getLeftX() * DriveConstants.kSteeringOutputModifier);
            }
        }
    }

    public void stopMotors() {
        m_driveLeft.stopMotor();
        m_driveRight.stopMotor();
    }

    public void toggleCurvatureMode() {
        if (!curvatureDriveMode) {
            curvatureDriveMode = true;
        } else {
            curvatureDriveMode = false;
        }
    }

    public void toggleRightStickMode() {
        if (!rightStickMode) {
            rightStickMode = true;
        } else {
            rightStickMode = false;
        }
    }
}
