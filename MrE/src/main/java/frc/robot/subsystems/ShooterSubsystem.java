// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: PIDSubsystem.

package frc.robot.subsystems;

import frc.robot.Constants.ShooterConstants;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
// import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class ShooterSubsystem extends SubsystemBase {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax m_shooterLeader;
    private CANSparkMax m_shooterFollower;
    private MotorControllerGroup m_shooter;
    private RelativeEncoder m_encoderShooter;
    private SparkMaxPIDController m_pidController;
    private double setpoint;

    // P I D Variables
    // private static final double kP = 1.0;
    // private static final double kI = 0.0;
    // private static final double kD = 0.0;
    // private static final double kF = 0.0;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Initialize your subsystem here
    public ShooterSubsystem(double setpoint) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        // super(new PIDController(kP, kI, kD));
        // getController().setTolerance(0.2);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        this.setpoint = setpoint;
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_shooterLeader = new CANSparkMax(10, MotorType.kBrushless);

        m_shooterLeader.restoreFactoryDefaults();
        m_shooterLeader.setInverted(false);
        m_shooterLeader.setIdleMode(IdleMode.kCoast);

        m_shooterFollower = new CANSparkMax(11, MotorType.kBrushless);

        m_shooterFollower.restoreFactoryDefaults();
        m_shooterFollower.setInverted(false);
        m_shooterFollower.setIdleMode(IdleMode.kCoast);
        m_shooterFollower.follow(m_shooterLeader);

        m_shooter = new MotorControllerGroup(m_shooterLeader, m_shooterFollower);
        addChild("m_shooter", m_shooter);

        // m_encoderShooter = new Encoder(6, 7, false, EncodingType.k4X);
        // addChild("m_encoderShooter", m_encoderShooter);
        // m_encoderShooter.setDistancePerPulse(1.0);
        m_encoderShooter = m_shooterLeader.getEncoder();
        m_encoderShooter.setVelocityConversionFactor(ShooterConstants.kVelocityConversionFactor);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_pidController = m_shooterLeader.getPIDController();

        // Use these to get going:
        // setSetpoint() - Sets where the PID controller should move the system
        // to
        // enable() - Enables the PID controller.
        // set PID coefficients
        m_pidController.setP(ShooterConstants.kP);
        m_pidController.setI(ShooterConstants.kI);
        m_pidController.setD(ShooterConstants.kD);
        m_pidController.setIZone(ShooterConstants.kIz);
        m_pidController.setFF(ShooterConstants.kFF);
        m_pidController.setOutputRange(ShooterConstants.kMinOutput, ShooterConstants.kMaxOutput);

        SmartDashboard.putNumber("Shooter P Gain", ShooterConstants.kP);
        SmartDashboard.putNumber("Shooter I Gain", ShooterConstants.kI);
        SmartDashboard.putNumber("Shooter D Gain", ShooterConstants.kD);
        SmartDashboard.putNumber("Shooter I Zone", ShooterConstants.kIz);
        SmartDashboard.putNumber("Shooter Feed Forward", ShooterConstants.kFF);
        SmartDashboard.putNumber("Shooter Max Output", ShooterConstants.kMaxOutput);
        SmartDashboard.putNumber("Shooter Min Output", ShooterConstants.kMinOutput);
        SmartDashboard.putNumber("Shooter RPM Setpoint", setpoint);

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        // super.periodic();
        // read PID coefficients from SmartDashboard
        double p = SmartDashboard.getNumber("Shooter P Gain", 0);
        double i = SmartDashboard.getNumber("Shooter I Gain", 0);
        double d = SmartDashboard.getNumber("Shooter D Gain", 0);
        double iz = SmartDashboard.getNumber("Shooter I Zone", 0);
        double ff = SmartDashboard.getNumber("Shooter Feed Forward", 0);
        double max = SmartDashboard.getNumber("Shooter Max Output", 0);
        double min = SmartDashboard.getNumber("Shooter Min Output", 0);
        double sp = SmartDashboard.getNumber("Shooter RPM Setpoint", 0);

        // if PID coefficients on SmartDashboard have changed, write new values to controller
        if((p != ShooterConstants.kP)) { m_pidController.setP(p); ShooterConstants.kP = p; }
        if((i != ShooterConstants.kI)) { m_pidController.setI(i); ShooterConstants.kI = i; }
        if((d != ShooterConstants.kD)) { m_pidController.setD(d); ShooterConstants.kD = d; }
        if((iz != ShooterConstants.kIz)) { m_pidController.setIZone(iz); ShooterConstants.kIz = iz; }
        if((ff != ShooterConstants.kFF)) { m_pidController.setFF(ff); ShooterConstants.kFF = ff; }
        if((max != ShooterConstants.kMaxOutput) || (min != ShooterConstants.kMinOutput)) { 
            m_pidController.setOutputRange(min, max); 
            ShooterConstants.kMinOutput = min; ShooterConstants.kMaxOutput = max; 
        }
        if((sp != setpoint)){ setpoint = sp; }
        m_pidController.setReference(setpoint, CANSparkMax.ControlType.kVelocity);
        
        SmartDashboard.putNumber("Shooter SetPoint", setpoint);
        SmartDashboard.putNumber("Shooter Velocity", m_encoderShooter.getVelocity());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

}
