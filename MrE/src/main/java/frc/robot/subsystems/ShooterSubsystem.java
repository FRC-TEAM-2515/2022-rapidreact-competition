// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: PIDSubsystem.

package frc.robot.subsystems;

import frc.robot.Constants.ShooterConstants;
import edu.wpi.first.wpilibj2.command.PIDSubsystem;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.math.controller.PIDController;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
// import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
// public class ShooterSubsystem extends PIDSubsystem {
    public class ShooterSubsystem extends SubsystemBase {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax m_shooterLeader;
    private CANSparkMax m_shooterFollower;
    private MotorControllerGroup m_shooter;
    private RelativeEncoder m_encoderShooter;
    public SparkMaxPIDController m_pidController;

    // P I D Variables
    // private static final double kP = ShooterConstants.kP;
    // private static final double kI = ShooterConstants.kI;
    // private static final double kD = ShooterConstants.kD;
    // private static final double kF = ShooterConstants.kF;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Initialize your subsystem here
    public ShooterSubsystem() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        // super(new PIDController(kP, kI, kD));
        // getController().setTolerance(0.2);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_shooterLeader = new CANSparkMax(ShooterConstants.kShooterLeaderID, MotorType.kBrushless);

        m_shooterLeader.restoreFactoryDefaults();
        m_shooterLeader.setIdleMode(IdleMode.kCoast);

        // m_shooterFollower = new CANSparkMax(ShooterConstants.kShooterFollowerID, MotorType.kBrushless);

        // m_shooterFollower.restoreFactoryDefaults();
        // m_shooterFollower.setInverted(false);
        // m_shooterFollower.setIdleMode(IdleMode.kCoast);
        m_pidController = m_shooterLeader.getPIDController();

        // m_shooter = new MotorControllerGroup(m_shooterLeader);
        // addChild("m_shooter", m_shooter);

        // m_encoderShooter = new Encoder(6, 7, false, EncodingType.k4X);
        m_encoderShooter = m_shooterLeader.getEncoder();
        // addChild("m_encoderShooter", m_encoderShooter);
        // m_encoderShooter.setDistancePerPulse(1.0);
        // m_encoderShooter.setVelocityConversionFactor(ShooterConstants.kVelocityConversionFactor);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // Use these to get going:
        // setSetpoint() - Sets where the PID controller should move the system
        // to
        // enable() - Enables the PID controller.
        m_pidController.setP(ShooterConstants.kP);
        m_pidController.setI(ShooterConstants.kI);
        m_pidController.setD(ShooterConstants.kD);
        m_pidController.setIZone(ShooterConstants.kIz);
        m_pidController.setFF(ShooterConstants.kFF);
        m_pidController.setOutputRange(ShooterConstants.kMinOutput, ShooterConstants.kMaxOutput);

        SmartDashboard.putNumber("Shooter P Gain", ShooterConstants.kP);
        SmartDashboard.putNumber("Shooter I Gain", ShooterConstants.kI);
        SmartDashboard.putNumber("Shooter D Gain", ShooterConstants.kD);
        SmartDashboard.putNumber("Shooter I Zone", ShooterConstants.kIz);
        SmartDashboard.putNumber("Shooter Feed Forward", ShooterConstants.kFF);
        SmartDashboard.putNumber("Shooter Max Output", ShooterConstants.kMaxOutput);
        SmartDashboard.putNumber("Shooter Min Output", ShooterConstants.kMinOutput);
    }

    @Override
    public void periodic() {
        // // This method will be called once per scheduler run
        // double minRPM = SmartDashboard.getNumber("Shooter Min RPM", 0);
        // double maxRPM = SmartDashboard.getNumber("Shooter Max RPM", 0);
        // if(minRPM != ShooterConstants.kMinRPM){ShooterConstants.kMinRPM = minRPM;
        // }
        // if(maxRPM != ShooterConstants.kMaxRPM){ShooterConstants.kMaxRPM = maxRPM;
        // }
        // super.periodic();
        SmartDashboard.putNumber("Shooter Velocity", m_encoderShooter.getVelocity());
        double p = SmartDashboard.getNumber("Shooter P Gain", 0);
        double i = SmartDashboard.getNumber("Shooter I Gain", 0);
        double d = SmartDashboard.getNumber("Shooter D Gain", 0);
        double iz = SmartDashboard.getNumber("Shooter I Zone", 0);
        double ff = SmartDashboard.getNumber("Shooter Feed Forward", 0);
        double max = SmartDashboard.getNumber("Shooter Max Output", 0);
        double min = SmartDashboard.getNumber("Shooter Min Output", 0);
        if((p != ShooterConstants.kP)) { m_pidController.setP(p); ShooterConstants.kP = p; }
        if((i != ShooterConstants.kI)) { m_pidController.setI(i); ShooterConstants.kI = i; }
        if((d != ShooterConstants.kD)) { m_pidController.setD(d); ShooterConstants.kD = d; }
        if((iz != ShooterConstants.kIz)) { m_pidController.setIZone(iz); ShooterConstants.kIz = iz; }
        if((ff != ShooterConstants.kFF)) { m_pidController.setFF(ff); ShooterConstants.kFF = ff; }
        if((max != ShooterConstants.kMaxOutput) || (min != ShooterConstants.kMinOutput)) { 
          m_pidController.setOutputRange(min, max); 
          ShooterConstants.kMinOutput = min; ShooterConstants.kMaxOutput = max; 
        }

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // @Override
    // public double getMeasurement() {
    //     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    //     // return m_encoderShooter.pidGet();
    //     return m_encoderShooter.getVelocity();

    //     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    // }

    // @Override
    // public void useOutput(double output, double setpoint) {
    //     output += setpoint * kF;
    //     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    //     m_shooter.set(output);

    //     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    // }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    public void stopMotors() {
        m_shooterLeader.set(0);
        // m_shooter.set(0);
    }

    public void setVelocity(double setPoint){
        m_pidController.setReference(setPoint, CANSparkMax.ControlType.kVelocity);
        SmartDashboard.putNumber("SetPoint", setPoint);
        SmartDashboard.putNumber("ProcessVariable", m_encoderShooter.getVelocity());
    }
    public void setOutput(double output){
        m_shooterLeader.set(output);
    }
    public boolean isRunning(){
       if(m_shooter.get() != 0.0){
           return true;
       }
       return false;
    }

    public double getRPMFromVision(){
        // Return RPM using Distance from Vision 
        return 0;
    }

    public boolean atSetpoint(){
        
        return false;
    }
}
